/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BatteryIndicatorPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/indicator.ts
var import_obsidian = require("obsidian");
var LEVEL_ICONS = [
  "battery-warning",
  "battery",
  "battery-low",
  "battery-medium",
  "battery-full"
];
var CHARGING_ICON = "battery-charging";
var CHARGING_ICON_ALT = "plug-zap";
var BatteryIndicator = class {
  constructor(plugin) {
    this.updateIndicator = (status = this.lastStatus) => {
      this.lastStatus = status;
      let icon;
      if (status.charging && !this.plugin.settings.separateChargingIcon)
        icon = CHARGING_ICON;
      else
        icon = LEVEL_ICONS[determineStep(status.level, this.plugin.settings.thresholds)];
      (0, import_obsidian.setIcon)(this.iconElement, icon);
      if (status.charging && this.plugin.settings.separateChargingIcon) {
        this.chargingIconElement.removeClass("hidden");
      } else {
        this.chargingIconElement.addClass("hidden");
      }
      if (this.plugin.settings.showPercentage) {
        this.textElement.setText(`${Math.round(status.level * 100)}%`);
        this.textElement.removeClass("hidden");
      } else {
        this.textElement.addClass("hidden");
      }
    };
    this.plugin = plugin;
    const statusBarItem = plugin.addStatusBarItem();
    const wrapper = statusBarItem.createEl("div", { cls: "wrapper" });
    this.textElement = wrapper.createEl("span");
    this.chargingIconElement = wrapper.createEl("span", { cls: "iconSpan" });
    (0, import_obsidian.setIcon)(this.chargingIconElement, CHARGING_ICON_ALT);
    this.iconElement = wrapper.createEl("span", { cls: "iconSpan" });
  }
};
function initializeIndicator(plugin) {
  const indicator = new BatteryIndicator(plugin);
  return indicator.updateIndicator;
}
function determineStep(level, thresholds) {
  for (let i = 0; i <= thresholds.length; i++) {
    if (level < thresholds[i])
      return i;
  }
  return thresholds.length;
}

// src/polling.ts
var BatteryIndicatorPolling = class {
  constructor(callback) {
    this.poll = async () => {
      const previousBatteryStatus = this.batteryStatus;
      this.batteryStatus = await getCurrentBatteryStatus();
      this.callback(this.batteryStatus);
      this.schedulePoll();
    };
    this.callback = callback;
    this.waittime = 5e3;
    (async () => {
      this.batteryStatus = await getCurrentBatteryStatus();
      callback(this.batteryStatus);
      this.schedulePoll();
    })();
  }
  stopPolling() {
    clearTimeout(this.timeout);
  }
  schedulePoll() {
    this.timeout = window.setTimeout(this.poll, this.waittime);
  }
};
function startPolling(callback) {
  console.log(callback);
  const poller = new BatteryIndicatorPolling(callback);
  return poller.stopPolling;
}
async function getCurrentBatteryStatus() {
  return await window.navigator.getBattery();
}

// src/settings.ts
var import_obsidian2 = require("obsidian");
var BatteryIndicatorSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin, callback) {
    super(app, plugin);
    this.plugin = plugin;
    this.callback = callback;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("Show percentage").setDesc("Show the battery percentage in addition to the icon.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showPercentage).onChange(async (value) => {
      this.plugin.settings.showPercentage = value;
      this.callback();
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Separate charging icon").setDesc("Show separate icons for charging indicator and current battery level.").addToggle((toggle) => toggle.setValue(this.plugin.settings.separateChargingIcon).onChange(async (value) => {
      this.plugin.settings.separateChargingIcon = value;
      this.callback();
      await this.plugin.saveSettings();
    }));
  }
};
function initializeSettings(app, plugin, callback) {
  plugin.addSettingTab(new BatteryIndicatorSettingsTab(app, plugin, callback));
}

// main.ts
var DEFAULT_SETTINGS = {
  thresholds: [
    0.2,
    0.4,
    0.6,
    0.8
  ],
  showPercentage: true,
  separateChargingIcon: false
};
var BatteryIndicatorPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    const indicatorCallback = initializeIndicator(this);
    this.stopPolling = startPolling(indicatorCallback);
    initializeSettings(this.app, this, indicatorCallback);
  }
  onunload() {
    this.stopPolling();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};

/* nosourcemap */